g++ -std=c++11 或 g++ -std=gnu++11

inline 函数的定义最好是放在头文件中

内存对齐规则：
    1、数据项只能存储在地址是数据项大小的整数倍的内存位置上
    2、数据占据总内存字节数字必须是对齐系数的整数倍[如果不是，那么会发生补齐操作]

每个特定平台上的编译器都有自己的默认“对齐系数”。通过预编译命令#pragma pack(k)，k=1,2,4,8,16来改变这个系数，
其中k就是需要指定的“对齐系数”；也可以使用#pragma pack()取消自定义字节对齐方式

类与结构体的不同点在于类默认是private，结构体默认是public

return *this返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&， 则是本身 ）。return this返回当前对象的地址（指向当前对象的指针）

在 C++ 中，这三种情况下拷贝构造函数会被使用：
1、一个对象以值传递的形式传入函数内。
2、一个对象以值传递的形式从函数返回。
3、一个对象通过另一个对象初始化。

std::move并不能移动任何东西，它唯一的功能：将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。
从实现上讲，std::move基本等同于一个类型转换：
static_cast<T&&>(lvalue);

std::move无条件转换到右值。就其本身而言，它没有move任何东西。
std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。
std::move和std::forward在运行期都没有做任何事情

拷贝构造函数和赋值函数区别
拷贝构造函数是在对象初始化时，分配一块空间并初始化，而赋值函数是对已经分配空间的对象进行赋值操作。
实现上，拷贝构造函数是构造函数，通过参数的对象初始化产生一个对象。赋值函数则是把一个对象赋值给另一个对象，需要先判断两个对象是否是同一个对象，若是则什么都不做，直接返回，若不是则需要先释放原对象内存，在赋值。(可以参考 shared_ptr 实现)
总结：
对象不存在，没有通过别的对象来初始化，就是构造函数。
对象不存在，通过别的对象来初始化，就是拷贝构造函数。
对象存在，通过别的对象来初始化，就是赋值函数。

结构体字节对齐原则：
无 #pragma pack
    结构内部各成员首地址必然是自身大小的整数倍。
    sizeof 最终结果必然是结构内部最大成员的整数倍，不够补齐
有 #pragma pack(n)
    结构内部各成员首地址必然是 min(n, 自身大小) 的整数倍。
    sizeof 最终结果必然是 min(n, 结构内部最大成员) 的整数倍，不够补齐。


声明和定义
变量定义：为变量分配空间，还可以为变量指定初始值。
变量声明：向程序表明变量的类型和名字，但不分配空间。可以通过 extern 关键字来声明而不定义，
extern 告诉编译器变量在别的地方定义了。
1、定义也是声明，声明不是定义。例如：
    extern int i 声明且不定义 i 变量，int i 声明且定义了 i 变量。
2、声明有初始值时，为当成定义
    extern int i=10 此时看成定义了 i 变量。
3、函数的声明和定义，区别在于是否带有花括号。

lambda 表达式
lambda 表达式定义一个匿名函数，并且可以捕获一定范围内的变量，基本格式如下：
[capture](params) mutable ->ReturnType {statement}

[capture]：捕获列表，可以捕获上下文的变量来供 lambda 函数使用
[var]：值传递的方式捕获 var
[&var]：引用传递的方式捕获 var
[=]：值传递的方式捕获父作用域的所有变量。
[&]：引用传递的方式捕获父作用域的所有变量。
[this]：值传递的方式捕获当前 this 指针。
(params)：参数列表，和普通函数参数列表一致，如果不传参数可以和 () 一起忽略。
mutable 修饰符号，默认情况下，lambda 表达式是一个 const 函数，可以用 mutable 取消他的常量性。若使用 mutable 修饰，参数列表不可省略。
**->**ReturnType：返回值类型。若是 void，可以省略。
{statement}：函数主体，和普通函数一样。








