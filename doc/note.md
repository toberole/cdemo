g++ -std=c++11 或 g++ -std=gnu++11

inline 函数的定义最好是放在头文件中

内存对齐规则：
    1、数据项只能存储在地址是数据项大小的整数倍的内存位置上
    2、数据占据总内存字节数字必须是对齐系数的整数倍[如果不是，那么会发生补齐操作]

每个特定平台上的编译器都有自己的默认“对齐系数”。通过预编译命令#pragma pack(k)，k=1,2,4,8,16来改变这个系数，
其中k就是需要指定的“对齐系数”；也可以使用#pragma pack()取消自定义字节对齐方式

类与结构体的不同点在于类默认是private，结构体默认是public

return *this返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&， 则是本身 ）。return this返回当前对象的地址（指向当前对象的指针）

在 C++ 中，这三种情况下拷贝构造函数会被使用：
1、一个对象以值传递的形式传入函数内。
2、一个对象以值传递的形式从函数返回。
3、一个对象通过另一个对象初始化。

std::move并不能移动任何东西，它唯一的功能：将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。
从实现上讲，std::move基本等同于一个类型转换：
static_cast<T&&>(lvalue);

std::move无条件转换到右值。就其本身而言，它没有move任何东西。
std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。
std::move和std::forward在运行期都没有做任何事情


















